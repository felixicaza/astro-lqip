---
import { join } from 'node:path'
import { readFile } from 'node:fs/promises'

import type { GetPlaiceholderReturn } from 'plaiceholder'
import { getPlaiceholder } from 'plaiceholder'

import type { Props as PictureProps } from 'astro/components/Picture.astro'
import { Picture as PictureComponent } from 'astro:assets'

type GetSVGReturn = GetPlaiceholderReturn['svg']
type LqipType = 'color' | 'css' | 'base64' | 'svg'
type Props = PictureProps & {
  lqip?: LqipType
}

const { class: className, lqip = 'base64', ...props } = Astro.props as Props

const PREFIX = '[astro-lqip]'

const imageMetadata = await resolveImageMetadata(props.src)
const lqipImage = await getLqip(imageMetadata, lqip)

let svgHTML = ''

if (lqip === 'svg') {
  function styleToString(style: Record<string, string>) {
    return Object.entries(style)
      .map(([key, val]) => `${key.replace(/([A-Z])/g, '-$1').toLowerCase()}:${val}`)
      .join(';')
  }

  function renderNode([tag, attrs, children]: [string, Record<string, any>, any[]]): string {
    let attrString = ''
    for (const [k, v] of Object.entries(attrs || {})) {
      if (k === 'style') {
        attrString += ` style="${styleToString(v)}"`
      } else {
        attrString += ` ${k}="${v}"`
      }
    }

    if (children && children.length > 0) {
      return `<${tag}${attrString}>${children.map(renderNode).join('')}</${tag}>`
    } else {
      return `<${tag}${attrString} />`
    }
  }

  if (Array.isArray(lqipImage)) {
    svgHTML = renderNode(lqipImage as [string, Record<string, any>, any[]])
  }
}

async function resolveImageMetadata(src: any) {
  if (typeof src === 'string') return null
  if ('then' in src && typeof src.then === 'function') return (await src).default
  if ('src' in src) return src
  return null
}

async function tryGenerateLqip(filePath: string, errorPrefix: string, isDevelopment: boolean, lqipType: LqipType) {
  try {
    const buffer = await readFile(filePath)
    const result = await getPlaiceholder(buffer)
    let lqipValue: string | GetSVGReturn | undefined

    switch (lqipType) {
      case 'color':
        lqipValue = result.color?.hex
        break
      case 'css':
        lqipValue = typeof result.css === 'object' && result.css.backgroundImage
          ? result.css.backgroundImage
          : String(result.css)
        break
      case 'svg':
        lqipValue = result.svg
        break
      case 'base64':
      default:
        lqipValue = result.base64
        break
    }

    if (isDevelopment) {
      console.log(`${PREFIX} LQIP (${lqipType}) successfully generated!`)
    } else {
      console.log(`${PREFIX} LQIP (${lqipType}) successfully generated for:`, filePath)
    }
    return lqipValue
  } catch (err) {
    console.error(`${errorPrefix} Error generating LQIP (${lqipType}) in:`, filePath, '\n', err)
    return undefined
  }
}

async function getLqip(imageMetadata: any, lqipType: LqipType) {
  if (!imageMetadata?.src) return undefined

  const isDevelopment = import.meta.env.MODE === 'development'

  if (isDevelopment && imageMetadata.src.startsWith('/@fs/')) {
    const filePath = imageMetadata.src.replace(/^\/@fs/, '').split('?')[0]
    return await tryGenerateLqip(filePath, PREFIX, isDevelopment, lqipType)
  }

  if (!isDevelopment && imageMetadata.src.startsWith('/_astro/')) {
    const buildPath = join(process.cwd(), 'dist', imageMetadata.src)
    return await tryGenerateLqip(buildPath, PREFIX, isDevelopment, lqipType)
  }
}

function getLqipStyle(lqipType: LqipType, lqipImage: string | GetSVGReturn | undefined) {
  if (!lqipImage) return {}

  switch (lqipType) {
    case 'css':
      return { '--lqip-background': lqipImage }
    case 'svg':
      return { '--lqip-background': `url('data:image/svg+xml;utf8,${encodeURIComponent(svgHTML)}')` }
    case 'color':
      return { '--lqip-background': lqipImage }
    case 'base64':
    default:
      return { '--lqip-background': `url('${lqipImage}')` }
  }
}

const lqipStyle = getLqipStyle(lqip, lqipImage)
---

<style is:inline>
  picture {
    --opacity: 1;
    --z-index: 0;

    position: relative;
    display: inline-block;
  }

  picture::after {
    content: "";
    inset: 0;
    width: 100%;
    height: 100%;
    position: absolute;
    pointer-events: none;
    transition: opacity 1s;
    opacity: var(--opacity);
    z-index: var(--z-index);
    background: var(--lqip-background);
    background-size: cover;
    background-position: 50% 50%;
  }

  picture img {
    z-index: 1;
    position: relative;
    overflow: hidden;
  }
</style>

<PictureComponent
  {...props}
  class={className}
  pictureAttributes={{ style: lqipStyle }}
  onload="parentElement.style.setProperty('--z-index', 1), parentElement.style.setProperty('--opacity', 0)"
/>
